name: Cleanup Workflow Runs
on:
  schedule:
    - cron: '0 0 * * 0'  # 每周日0点运行
  workflow_dispatch:
    inputs:
      keep_days:
        description: "保留最近多少天（0=全部清理，默认0）"
        required: false
        default: "0"
      repositories:
        description: "要清理的仓库（格式：owner/repo，多个用逗号分隔，留空为当前仓库）"
        required: false
        default: ""

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: 设置目标仓库列表
        id: set-repos
        run: |
          # 如果没有输入，使用当前仓库
          if [ -z "${{ github.event.inputs.repositories }}" ]; then
            REPOS="${{ github.repository }}"
          else
            REPOS="${{ github.event.inputs.repositories }}"
          fi
          
          # 清理空格，确保格式正确
          REPOS=$(echo "$REPOS" | tr -d ' ' | sed 's/,,*/,/g' | sed 's/^,//' | sed 's/,$//')
          
          echo "repositories=$REPOS" >> $GITHUB_OUTPUT
          echo "🔍 将清理仓库：$REPOS"
      
      - name: 清理工作流运行
        env:
          KEEP_DAYS: ${{ github.event.inputs.keep_days }}
          REPOSITORIES: ${{ steps.set-repos.outputs.repositories }}
        run: |
          # 设置默认值
          : "${KEEP_DAYS:=0}"
          
          echo "参数配置："
          echo "  - 保留天数: $KEEP_DAYS (0=全部清理)"
          echo "  - 目标仓库: $REPOSITORIES"
          
          # 如果没有仓库，退出
          if [ -z "$REPOSITORIES" ]; then
            echo "❌ 错误：未指定要清理的仓库"
            exit 1
          fi
          
          # 分割仓库列表
          IFS=',' read -ra REPO_ARRAY <<< "$REPOSITORIES"
          
          # 遍历所有仓库
          for TARGET_REPO in "${REPO_ARRAY[@]}"; do
            echo ""
            echo "========================================"
            echo "🎯 开始清理仓库：$TARGET_REPO"
            echo "========================================"
            
            # 构建查询条件
            JQ_FILTER='.workflow_runs[] | select(.status=="completed")'
            
            # 如果设置了保留天数，添加时间筛选
            if [ "$KEEP_DAYS" -gt 0 ]; then
              THRESHOLD=$(date -u -d "${KEEP_DAYS} days ago" '+%Y-%m-%dT%H:%M:%SZ')
              echo "📅 保留最近 $KEEP_DAYS 天的运行记录"
              echo "⏰ 阈值时间(UTC)：$THRESHOLD"
              JQ_FILTER="$JQ_FILTER | select(.created_at < \"$THRESHOLD\")"
            else
              echo "⚠️ 警告：将清理所有已完成的工作流运行"
            fi
            
            # 初始化计数
            TOTAL_DELETED=0
            TOTAL_FAILED=0
            page=1
            
            # 主循环（清理单个仓库）
            while true; do
              echo "📄 正在获取第 $page 页..."
              
              # 获取工作流运行
              RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.AUTH_PAT }}" \
                            "https://api.github.com/repos/$TARGET_REPO/actions/runs?per_page=100&page=$page")
              
              # 检查响应
              if ! echo "$RESPONSE" | jq -e '.workflow_runs' > /dev/null 2>&1; then
                echo "❌ API 响应异常，可能仓库 '$TARGET_REPO' 不存在或无权限"
                echo "响应内容："
                echo "$RESPONSE" | head -5
                break
              fi
              
              # 获取运行ID
              RUN_IDS=$(echo "$RESPONSE" | jq -r "$JQ_FILTER | .id" | tr '\n' ' ')
              
              # 如果没有数据
              if [ -z "$RUN_IDS" ] || [ "$RUN_IDS" = " " ]; then
                echo "✅ 第 $page 页没有可删除的运行"
                TOTAL_COUNT=$(echo "$RESPONSE" | jq '.total_count // 0')
                TOTAL_PROCESSED=$(( (page-1) * 100 ))
                if [ $TOTAL_PROCESSED -ge $TOTAL_COUNT ]; then
                  echo "📊 已处理完所有 $TOTAL_COUNT 个记录"
                  break
                fi
              else
                # 清理RUN_IDS
                RUN_IDS=$(echo "$RUN_IDS" | xargs)
                COUNT=$(echo "$RUN_IDS" | wc -w)
                echo "🗑️ 第 $page 页发现 $COUNT 个待删除运行"
                
                # 删除当前页的运行
                for RUN_ID in $RUN_IDS; do
                  echo "  删除运行 ID: $RUN_ID"
                  
                  DELETE_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
                    -H "Authorization: token ${{ secrets.AUTH_PAT }}" \
                    "https://api.github.com/repos/$TARGET_REPO/actions/runs/$RUN_ID")
                  
                  # 检查删除是否成功
                  if [ "$DELETE_RESPONSE" = "204" ]; then
                    echo "    ✅ 删除成功"
                    TOTAL_DELETED=$((TOTAL_DELETED + 1))
                  else
                    echo "    ❌ 删除失败 (HTTP $DELETE_RESPONSE)"
                    TOTAL_FAILED=$((TOTAL_FAILED + 1))
                  fi
                  
                  # 添加延迟避免速率限制
                  sleep 0.2
                done
                
                echo "📊 第 $page 页完成"
              fi
              
              # 继续下一页
              page=$((page + 1))
            done
            
            echo ""
            echo "✅ 仓库 $TARGET_REPO 清理完成"
            echo "📈 统计：成功删除 $TOTAL_DELETED 个运行，失败 $TOTAL_FAILED 个"
            echo ""
          done
          
          echo "🎉 所有指定仓库清理完成！"

# ========================================
# 配置说明：
# 1. 创建 Personal Access Token (PAT)：
#    - 访问 GitHub → Settings → Developer settings → Personal access tokens
#    - 生成 token，至少选择权限：repo (完全访问仓库)、workflow (读写工作流)
#    
# 2. 将 PAT 添加到仓库 Secrets：
#    - 进入仓库 → Settings → Secrets and variables → Actions
#    - 新建 Secret，名称：AUTH_PAT，值：粘贴刚才复制的 token
#    
# 3. 使用说明：
#    - 定时任务：每周日0点自动运行，默认清理所有已完成运行
#    - 手动触发：可指定保留天数(0=全部清理)和仓库列表(逗号分隔)
#    - 示例：repositories: user/repo1,user/repo2，keep_days: 7
#
# 4. 使用 AUTH_PAT - 可以直接复制到任何仓库
#    secrets.AUTH_PAT
#    使用 GITHUB_TOKEN - 仅限当前仓库，无跨项目权限
#    secrets.GITHUB_TOKEN
# ========================================
